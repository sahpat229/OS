/******************************
Sharang Phadke
12/08/2013
ECE 357: OS

sched.c
******************************/

//void sched_init(void (*init_fn))
//  Initializes scheduling system, including a periodic interval timer, a
//  signal handler for that timer, and the initial task with pid 1. The initial
//  task is then made runnable and execution is transfered to it. This function
//  is not expected to return.
void sched_init(void (*init_fn)){
}

//int sched_fork()
//  Creates a new simulated task which is a copy of the caller. Allocates a new
//  pid for the child, and makes the child runnable and eligible to be
//  scheduled. The parent and child processes are executed in the same address
//  space, but a new private stack area must be allocated for the child,
//  initialized to a copy of the parent's. This function returns 0 to the child
//  and the child's pid to the parent. It returns -1 on error.
int sched_fork(){
}

//void sched_exit(int code)
//  Terminates the current task, making it a ZOMBIE, and stores the exit code.
//  If a parent is sleeping in sched_wait(), it is woken up and the exit code
//  is returned to it. This function does not return. 
void sched_exit(int code){
}

//int sched_wait(int *exit_code)
//  Returns the exit code of a zombie child and frees the resources of that
//  child. If there is more than one such child, the order in which the codes
//  are returned is not defined. If there are no zombie children, but the
//  caller does have at least one child, the caller is placed in SLEEPING, to
//  be woken up when a child calls sched_exit(). If there are no children,
//  -1 is returned immediately, otherwise 0 is returned.
int sched_wait(int *exit_code){
}

//void sched_nice(int niceval)
//  Sets the current task's nice value to the supplied parameter. Nice values
//  range from +19 (least preferred static priority) to -20 (most preferred).
void sched_nice(int niceval){
}

//int sched_getpid()
//  Returns the current task's pid
int sched_getpid(){
}

//int sched_getppid()
//  Returns the pid of the parent of the current task
int sched_getppid(){
}

//long sched_gettick()
//  Returns the number of timer ticks since startup
long sched_gettick(){
}

//void sched_ps()
//  Outputs to stdout a list of all of the current tasks, including sleeping
//  and zombie tasks. Lists the following information for each task:
//      pid
//      ppid
//      current state
//      base address of private stack area
//      if SLEEPING, the address of the wait queue
//      static priority
//      dynamic priority
//      total CPU time used (in ticks)
//  This function serves as the signal handler for SIGABRT signals
void sched_ps(){
}

//void sched_switch()
//  Analogous to the Linux schedule(). This is the sole place where a context
//  switch is made. The current task is placed on the run queue (assuming it is
//  READY), and the next best READY task is selected from the runqueue and
//  placed in the RUNNING state. A context switch is made.
void sched_switch(){
}

//void sched_tick()
//  Signal handler for the SIGVTALRM signal generated by the periodic timer.
//  Each occurrence of the timer signal is considered a tick. This function
//  returns the number of ticks since sched_init. If the time slice of the
//  currently running task has expired, it is marked as READY and placed on
//  the run queue based on its current dynamic priority. sched_switch() is
//  called to cause the new task to be run.
void sched_tick(){
    /* remember SIGVTALARM will, by default, be masked on entry to your
     * signal handler*/
}
