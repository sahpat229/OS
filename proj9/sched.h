/******************************
Sharang Phadke
12/08/2013
ECE 357: OS

sched.h
******************************/

#ifndef _SCHED_H_
#define _SCHED_H_

#define SCHED_NPROC 257
#define SCHED_READY 1
#define SCHED_RUNNING 2
#define SCHED_SLEEPING 3
#define SCHED_ZOMBIE 4
#define STACK_SIZE 65536

#include "savectx64.h"


struct sched_proc {
    int pid;
    int ppid;
    int task_state;
    int s_priority;
    int d_priority;
    int remaining_ticks;
    int total_ticks;
    int exit_code;
    int *waitq[SCHED_NPROC];
    void *stack;
    struct savectx ctx;
};

//void sched_init(void (*init_fn))
//  Initializes scheduling system, including a periodic interval timer, a
//  signal handler for that timer, and the initial task with pid 1. The initial
//  task is then made runnable and execution is transfered to it. This function
//  is not expected to return.
void sched_init(void (*init_fn)());

//int sched_fork()
//  Creates a new simulated task which is a copy of the caller. Allocates a new
//  pid for the child, and makes the child runnable and eligible to be
//  scheduled. The parent and child processes are executed in the same address
//  space, but a new private stack area must be allocated for the child,
//  initialized to a copy of the parent's. This function returns 0 to the child
//  and the child's pid to the parent. It returns -1 on error.
int sched_fork();

//void sched_exit(int code)
//  Terminates the current task, making it a ZOMBIE, and stores the exit code.
//  If a parent is sleeping in sched_wait(), it is woken up and the exit code
//  is returned to it. This function does not return. 
void sched_exit(int code);

//int sched_wait(int *exit_code)
//  Returns the exit code of a zombie child and frees the resources of that
//  child. If there is more than one such child, the order in which the codes
//  are returned is not defined. If there are no zombie children, but the
//  caller does have at least one child, the caller is placed in SLEEPING, to
//  be woken up when a child calls sched_exit(). If there are no children,
//  -1 is returned immediately, otherwise 0 is returned.
int sched_wait(int *exit_code);

//void sched_nice(int niceval)
//  Sets the current task's nice value to the supplied parameter. Nice values
//  range from +19 (least preferred static priority) to -20 (most preferred).
void sched_nice(int niceval);

//int sched_getpid()
//  Returns the current task's pid
int sched_getpid();

//int sched_getppid()
//  Returns the pid of the parent of the current task
int sched_getppid();

//int sched_gettick()
//  Returns the number of timer ticks since startup
int sched_gettick();

//void sched_ps()
//  Outputs to stdout a list of all of the current tasks, including sleeping
//  and zombie tasks. Lists the following information for each task:
//      pid
//      ppid
//      current state
//      base address of private stack area
//      static priority
//      dynamic priority
//      total CPU time used (in ticks)
//      if SLEEPING, the address of the wait queue
//  This function serves as the signal handler for SIGABRT signals
void sched_ps();

//void _sched_switch()
//  Analogous to the Linux schedule(). This is the sole place where a context
//  switch is made. The current task is placed on the run queue (assuming it is
//  READY), and the next best READY task is selected from the runqueue and
//  placed in the RUNNING state. A context switch is made.
void _sched_switch();

//void _sched_tick()
//  Signal handler for the SIGVTALRM signal generated by the periodic timer.
//  Each occurrence of the timer signal is considered a tick. This function
//  returns the number of ticks since sched_init. If the time slice of the
//  currently running task has expired, it is marked as READY and placed on
//  the run queue based on its current dynamic priority. _sched_switch() is
//  called to cause the new task to be run.
void _sched_tick();


#endif //_SCHED_H_
